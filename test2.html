<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Canvas</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            cursor: none; /* Hide default cursor */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="cosmicCanvas"></canvas>

    <script>
        const canvas = document.getElementById('cosmicCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let stars = [];
        let cosmicDust = [];
        let meteors = [];
        let comets = [];
        let subtleExplosions = [];
        let supernovas = [];

        const STAR_COUNT = 500;
        const DUST_PARTICLE_COUNT = 1000;
        const METEOR_SPAWN_INTERVAL = 200; // frames
        const COMET_SPAWN_INTERVAL = 400; // frames
        const MAX_METEORS = 10;
        const MAX_COMETS = 5;
        const SUPERNOVA_CHANCE = 0.0005; // Chance per frame for a supernova to appear

        let frameCount = 0;

        // Star properties
        function createStar() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 1.5 + 0.5, // 0.5 to 2
                alpha: Math.random(),
                speed: Math.random() * 0.5 + 0.1, // 0.1 to 0.6
                direction: Math.random() * Math.PI * 2 // Random direction
            };
        }

        // Cosmic Dust properties
        function createCosmicDust() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 0.8 + 0.1, // 0.1 to 0.9
                alpha: Math.random() * 0.6,
                speed: Math.random() * 0.2 + 0.05,
                direction: Math.random() * Math.PI * 2
            };
        }

        // Meteor properties
        function createMeteor() {
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y, vx, vy;

            switch (side) {
                case 0: // Top
                    x = Math.random() * canvas.width;
                    y = -20; // Start slightly off-screen
                    vx = (Math.random() - 0.5) * 2; // -1 to 1
                    vy = Math.random() * 2 + 1; // 1 to 3
                    break;
                case 1: // Right
                    x = canvas.width + 20;
                    y = Math.random() * canvas.height;
                    vx = -(Math.random() * 2 + 1); // -1 to -3
                    vy = (Math.random() - 0.5) * 2;
                    break;
                case 2: // Bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 20;
                    vx = (Math.random() - 0.5) * 2;
                    vy = -(Math.random() * 2 + 1); // -1 to -3
                    break;
                case 3: // Left
                    x = -20;
                    y = Math.random() * canvas.height;
                    vx = Math.random() * 2 + 1; // 1 to 3
                    vy = (Math.random() - 0.5) * 2;
                    break;
            }

            return {
                x: x,
                y: y,
                radius: Math.random() * 3 + 2, // 2 to 5
                color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                vx: vx,
                vy: vy,
                trail: [],
                trailLength: Math.floor(Math.random() * 10) + 5,
                life: 1, // For fade-out effect
                isComet: false
            };
        }

        // Comet properties (similar to meteor but with a longer, more distinct tail)
        function createComet() {
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y, vx, vy;

            switch (side) {
                case 0: // Top
                    x = Math.random() * canvas.width;
                    y = -50; // Start further off-screen
                    vx = (Math.random() - 0.5) * 3; // -1.5 to 1.5
                    vy = Math.random() * 3 + 2; // 2 to 5
                    break;
                case 1: // Right
                    x = canvas.width + 50;
                    y = Math.random() * canvas.height;
                    vx = -(Math.random() * 3 + 2); // -2 to -5
                    vy = (Math.random() - 0.5) * 3;
                    break;
                case 2: // Bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 50;
                    vx = (Math.random() - 0.5) * 3;
                    vy = -(Math.random() * 3 + 2); // -2 to -5
                    break;
                case 3: // Left
                    x = -50;
                    y = Math.random() * canvas.height;
                    vx = Math.random() * 3 + 2; // 2 to 5
                    vy = (Math.random() - 0.5) * 3;
                    break;
            }

            return {
                x: x,
                y: y,
                radius: Math.random() * 5 + 3, // 3 to 8
                color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                vx: vx,
                vy: vy,
                trail: [],
                trailLength: Math.floor(Math.random() * 20) + 10,
                life: 1, // For fade-out effect
                isComet: true
            };
        }

        // Subtle explosion properties (for when meteors/comets fade out)
        function createSubtleExplosion(x, y, color) {
            const particles = [];
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    radius: Math.random() * 2 + 0.5,
                    color: color,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    alpha: 1
                });
            }
            return { particles: particles, life: 1 };
        }

        // Supernova properties
        function createSupernova() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const maxRadius = Math.random() * 50 + 30; // 30 to 80
            const duration = Math.random() * 100 + 100; // 100 to 200 frames
            return {
                x: x,
                y: y,
                radius: 0,
                maxRadius: maxRadius,
                alpha: 1,
                life: 0,
                duration: duration,
                color: `hsl(${Math.random() * 360}, 100%, 80%)`
            };
        }

        // Initialize elements
        function init() {
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push(createStar());
            }
            for (let i = 0; i < DUST_PARTICLE_COUNT; i++) {
                cosmicDust.push(createCosmicDust());
            }
        }

        // Draw functions
        function drawBackground() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawStars() {
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.fill();

                // Update position for subtle movement
                star.x += Math.cos(star.direction) * star.speed;
                star.y += Math.sin(star.direction) * star.speed;

                // Wrap around screen
                if (star.x < 0) star.x = canvas.width;
                if (star.x > canvas.width) star.x = 0;
                if (star.y < 0) star.y = canvas.height;
                if (star.y > canvas.height) star.y = 0;

                // Twinkling effect
                star.alpha += (Math.random() - 0.5) * 0.02; // Small random change
                if (star.alpha > 1) star.alpha = 1;
                if (star.alpha < 0) star.alpha = 0;
            });
        }

        function drawCosmicDust() {
            cosmicDust.forEach(dust => {
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${dust.alpha})`;
                ctx.fill();

                // Update position
                dust.x += Math.cos(dust.direction) * dust.speed;
                dust.y += Math.sin(dust.direction) * dust.speed;

                // Wrap around screen
                if (dust.x < 0) dust.x = canvas.width;
                if (dust.x > canvas.width) dust.x = 0;
                if (dust.y < 0) dust.y = canvas.height;
                if (dust.y > canvas.height) dust.y = 0;
            });
        }

        function drawMeteors() {
            for (let i = 0; i < meteors.length; i++) {
                const meteor = meteors[i];

                // Update position
                meteor.x += meteor.vx;
                meteor.y += meteor.vy;

                // Add current position to trail
                meteor.trail.push({ x: meteor.x, y: meteor.y });
                if (meteor.trail.length > meteor.trailLength) {
                    meteor.trail.shift(); // Remove oldest trail segment
                }

                // Draw trail
                ctx.beginPath();
                ctx.moveTo(meteor.trail[0].x, meteor.trail[0].y);
                for (let j = 1; j < meteor.trail.length; j++) {
                    const segment = meteor.trail[j];
                    const prevSegment = meteor.trail[j - 1];
                    const alpha = (j / meteor.trail.length) * meteor.life; // Fade trail with meteor life
                    ctx.lineTo(segment.x, segment.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = meteor.radius / 2;
                    ctx.stroke();
                }

                // Draw meteor body
                ctx.beginPath();
                ctx.arc(meteor.x, meteor.y, meteor.radius, 0, Math.PI * 2);
                ctx.fillStyle = meteor.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = meteor.color;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow

                // Remove meteor if it goes off-screen
                if (meteor.x < -meteor.radius * 2 || meteor.x > canvas.width + meteor.radius * 2 ||
                    meteor.y < -meteor.radius * 2 || meteor.y > canvas.height + meteor.radius * 2) {
                    meteors.splice(i, 1);
                    i--;
                }
            }
        }

        function drawComets() {
            for (let i = 0; i < comets.length; i++) {
                const comet = comets[i];

                // Update position
                comet.x += comet.vx;
                comet.y += comet.vy;

                // Add current position to trail
                comet.trail.push({ x: comet.x, y: comet.y });
                if (comet.trail.length > comet.trailLength) {
                    comet.trail.shift(); // Remove oldest trail segment
                }

                // Draw trail (more pronounced for comets)
                ctx.beginPath();
                ctx.moveTo(comet.trail[0].x, comet.trail[0].y);
                for (let j = 1; j < comet.trail.length; j++) {
                    const segment = comet.trail[j];
                    const prevSegment = comet.trail[j - 1];
                    const alpha = (j / comet.trail.length) * comet.life; // Fade trail with comet life
                    ctx.lineTo(segment.x, segment.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = comet.radius / 1.5;
                    ctx.stroke();
                }

                // Draw comet body
                ctx.beginPath();
                ctx.arc(comet.x, comet.y, comet.radius, 0, Math.PI * 2);
                ctx.fillStyle = comet.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = comet.color;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow

                // Remove comet if it goes off-screen
                if (comet.x < -comet.radius * 2 || comet.x > canvas.width + comet.radius * 2 ||
                    comet.y < -comet.radius * 2 || comet.y > canvas.height + comet.radius * 2) {
                    comets.splice(i, 1);
                    i--;
                }
            }
        }

        function drawExplosions() {
            for (let i = 0; i < subtleExplosions.length; i++) {
                const explosion = subtleExplosions[i];
                explosion.life -= 0.02; // Fade out

                if (explosion.life <= 0) {
                    subtleExplosions.splice(i, 1);
                    i--;
                    continue;
                }

                explosion.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.alpha -= 0.03; // Fade particles
                    p.radius *= 0.95; // Shrink particles

                    if (p.alpha <= 0) return; // Don't draw if fully faded

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                    ctx.fill();
                });
            }
        }

        function drawSupernovas() {
            for (let i = 0; i < supernovas.length; i++) {
                const supernova = supernovas[i];
                supernova.life++;

                // Expand and then fade
                if (supernova.life <= supernova.duration / 2) {
                    supernova.radius = supernova.maxRadius * (supernova.life / (supernova.duration / 2));
                    supernova.alpha = 1;
                } else {
                    supernova.alpha = 1 - ((supernova.life - supernova.duration / 2) / (supernova.duration / 2));
                }

                if (supernova.alpha <= 0) {
                    supernovas.splice(i, 1);
                    i--;
                    continue;
                }

                ctx.beginPath();
                ctx.arc(supernova.x, supernova.y, supernova.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${supernova.alpha})`;
                ctx.shadowBlur = supernova.radius / 2;
                ctx.shadowColor = supernova.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            drawBackground();
            drawCosmicDust();
            drawStars();
            drawMeteors();
            drawComets();
            drawExplosions();
            drawSupernovas();

            // Spawn new meteors
            if (frameCount % METEOR_SPAWN_INTERVAL === 0 && meteors.length < MAX_METEORS) {
                meteors.push(createMeteor());
            }

            // Spawn new comets
            if (frameCount % COMET_SPAWN_INTERVAL === 0 && comets.length < MAX_COMETS) {
                comets.push(createComet());
            }

            // Chance for a supernova
            if (Math.random() < SUPERNOVA_CHANCE) {
                supernovas.push(createSupernova());
            }

            frameCount++;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Re-initialize stars and dust for new dimensions
            stars = [];
            cosmicDust = [];
            init();
        });

        // Mouse effect (optional, for subtle interaction)
        let mouseX = 0;
        let mouseY = 0;
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function applySubtleMouseEffects() {
            // Example: Stars slightly move away from mouse
            stars.forEach(star => {
                const dx = star.x - mouseX;
                const dy = star.y - mouseY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) { // If within 100px of mouse
                    const angle = Math.atan2(dy, dx);
                    star.x += Math.cos(angle) * 0.1; // Push slightly
                    star.y += Math.sin(angle) * 0.1;
                }
            });
        }

        init();
        animate();
    </script>
</body>
</html>